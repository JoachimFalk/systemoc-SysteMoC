
#include <callib.hpp>

class m_MCadd: public smoc_actor {
// The actor has 4 Ports.
public: 
   smoc_port_in<cal_list<int>::t> LAST;
   smoc_port_in<cal_list<int>::t> TEX;
   smoc_port_in<int> MV;
   smoc_port_out<cal_list<int>::t> VID;

// The actor has 2 Parameters and 16 Variable declarations.
private: 
   const int WINSIZE;
   const int MAXMBWIDTH;
   int MBwidth; 
    int MBheight; 
    int rounding_type; 
    int next_x; 
    int next_y; 
    int next_n; 
    int int_buf_count; 
    int int_buf_count_ss; 
    int ext_buf_count; 
    int ext_buf_count_ss; 
    int frame_count; 
    int frame_number; 
    int head_index; 
    
   cal_list<int>::t initList(int v, int size) const {
      cal_list<int>::t ret_list;
   
     for (unsigned int i = 1; i <= size; ++i) 
                     {      
        ret_list.push_back(v);   
     }

   return( ret_list );
   }
   
   int MBbuf_size; 
    int MBbuf_ptr; 
     cal_list<cal_list<int>::t>::t MBbuf; 
    
   void MBbuf_add(cal_list<int>::t b) {
   MBbuf_ptr = (MBbuf_ptr + 1); 
   if (MBbuf_ptr >= MBbuf_size) { 
      MBbuf_ptr = 0; 
   }
   MBbuf[MBbuf_ptr] = b;
   }
 
   
   cal_list<int>::t MBbuf_get(int offset) const {
      int ptr = (MBbuf_ptr - offset);
      int ptr_wrapped = (ptr < 0) ? (ptr + MBbuf_size) : ((ptr >= MBbuf_size) ? (ptr - MBbuf_size) : (ptr));
   return( MBbuf[ptr_wrapped] );
   }
   
   
   int detect_skipped(int x, int y, int n) const {
   return( (x == next_x && y == next_y && n == next_n) ? 0 : (1) );
   }
   
   
   void next_block() {
   next_n = (next_n + 1); 
   if (next_n == 6) { 
      next_n = 0; 
      next_x = (next_x + 1); 
      if (next_x == MBwidth) { 
      next_x = 0; 
      next_y = (next_y + 1); 
      if (next_y == MBheight) { 
      next_y = 0; 
   }
   }
   }
   }
 
   
   int xadjust(int n, int dx) const {
   return( (n < 4) ? ((6 * rshift(dx, 4)) + (cal_bitand(dx, 8) == 0) ? 0 : ((n == 0 || n == 2) ? 1 : (5))) : ((6 * rshift(dx, 3))) );
   }
   
   
   int yadjust(int n, int dy) const {
   return( (n < 4) ? ((6 * MBwidth * rshift(dy, 4)) + (cal_bitand(dy, 8) == 0) ? 0 : ((n == 0 || n == 1) ? 2 : (((6 * MBwidth) - 2)))) : ((6 * MBwidth * rshift(dy, 3))) );
   }
   
   
   int get_pixel(int x, int y, int n, int dx, int dy) const {
   return( MBbuf_get(((head_index - xadjust(n, dx)) - yadjust(n, dy)))[(cal_bitand(dx, 7) + lshift(cal_bitand(dy, 7), 3))] );
   }
   
   
   int xyclip(int xy, int xymax, int dxy) const {
   return( (xy + dxy < 0) ? (-xy) : ((xy + dxy >= xymax) ? (xymax - xy - 1) : (dxy)) );
   }
   
   
   int xpixel(int x, int n) const {
   return( (n == 0 || n == 2) ? lshift(x, 4) : ((n == 1 || n == 3) ? (lshift(x, 4) + 8) : (lshift(x, 3))) );
   }
   
   
   int ypixel(int y, int n) const {
   return( (n == 0 || n == 1) ? lshift(y, 4) : ((n == 2 || n == 3) ? (lshift(y, 4) + 8) : (lshift(y, 3))) );
   }
   
   
   cal_list<int>::t comp_block(int x, int y, int n, int mvx, int mvy) const {
      cal_list<int>::t ret_list;
      int lmvx = rshift(mvx, 1);
      int lmvy = rshift(mvy, 1);
      int maxx = lshift(MBwidth, (n < 4) ? 4 : (3));
      int maxy = lshift(MBheight, (n < 4) ? 4 : (3));
      int ulx = xpixel(x, n);
      int uly = ypixel(y, n);
      cal_list<int>::t b;
   
     for (unsigned int yy = 0; yy <= 8; ++yy) 
                     for (unsigned int xx = 0; xx <= 8; ++xx) 
                     {      
        b.push_back(get_pixel(x, y, n, xyclip(ulx, maxx, (xx + lmvx)), xyclip(uly, maxy, (yy + lmvy))));   
     }
;
   if (cal_bitand(mvx, 1) == 0) 
     { if (cal_bitand(mvy, 1) == 0) 
     { 
     for (unsigned int yy = 0; yy <= 7; ++yy) 
                     for (unsigned int xx = 0; xx <= 7; ++xx) 
                     {      
        ret_list.push_back(b[((yy * 9) + xx)]);   
     }

     } 
     else { 
     for (unsigned int yy = 0; yy <= 7; ++yy) 
                     for (unsigned int xx = 0; xx <= 7; ++xx) 
                     {      
        ret_list.push_back(rshift((b[((yy * 9) + xx)] + b[((yy * 9) + xx + 9)] + 1 - rounding_type), 1));   
     }

     }
     } 
     else { if (cal_bitand(mvy, 1) == 0) 
     { 
     for (unsigned int yy = 0; yy <= 7; ++yy) 
                     for (unsigned int xx = 0; xx <= 7; ++xx) 
                     {      
        ret_list.push_back(rshift((b[((yy * 9) + xx)] + b[((yy * 9) + xx + 1)] + 1 - rounding_type), 1));   
     }

     } 
     else { 
     for (unsigned int yy = 0; yy <= 7; ++yy) 
                     for (unsigned int xx = 0; xx <= 7; ++xx) 
                     {      
        ret_list.push_back(rshift((b[((yy * 9) + xx)] + b[((yy * 9) + xx + 1)] + b[((yy * 9) + xx + 9)] + b[((yy * 9) + xx + 10)] + 2 - rounding_type), 2));   
     }

     }
     }
   return( ret_list );
   }
   
   
   int clip(int x) const {
   return( (x < 0) ? 0 : ((x > 255) ? 255 : (x)) );
   }
   
   
   cal_list<int>::t combine(cal_list<int>::t a, cal_list<int>::t b) const {
      cal_list<int>::t ret_list;
   
     for (unsigned int i = 0; i <= 63; ++i) 
                     {      
        ret_list.push_back(clip((a[i] + b[i])));   
     }

   return( ret_list );
   }
   
   
// The actor has 10 Actions and 10 Guards.
private:
bool m_MCadd::guard_newFrame(void)  const {
   const int cmd = MV[0];
   const int x = MV[1];
   const int y = MV[2];
   const int rounding = MV[3];
   const int unused1 = MV[4];
   const int unused2 = MV[5];
   return( (cmd == (-1)) );
}
bool m_MCadd::guard_docmd_missingBlock(void)  const {
   const int cmd = MV[0];
   const int x = MV[1];
   const int y = MV[2];
   const int n = MV[3];
   const int mvx = MV[4];
   const int mvy = MV[5];
   return( (cmd >= 0) && (detect_skipped(x, y, n) == 1) );
}
bool m_MCadd::guard_docmd_textureOnly(void)  const {
   const int cmd = MV[0];
   const int x = MV[1];
   const int y = MV[2];
   const int n = MV[3];
   const int mvx = MV[4];
   const int mvy = MV[5];
   const cal_list<int>::t &tex = TEX[0];
   return( (cmd == 6) && (detect_skipped(x, y, n) == 0) );
}
bool m_MCadd::guard_docmd_nothing(void)  const {
   const int cmd = MV[0];
   const int x = MV[1];
   const int y = MV[2];
   const int n = MV[3];
   const int mvx = MV[4];
   const int mvy = MV[5];
   return( (cmd == 0) && (detect_skipped(x, y, n) == 0) );
}
bool m_MCadd::guard_docmd_motionOnly(void)  const {
   const int cmd = MV[0];
   const int x = MV[1];
   const int y = MV[2];
   const int n = MV[3];
   const int mvx = MV[4];
   const int mvy = MV[5];
   cal_list<int>::t b = comp_block(x, y, n, mvx, mvy);
   return( (cmd == 0 || cmd == 1) && (detect_skipped(x, y, n) == 0) );
}
bool m_MCadd::guard_docmd_both(void)  const {
   const int cmd = MV[0];
   const int x = MV[1];
   const int y = MV[2];
   const int n = MV[3];
   const int mvx = MV[4];
   const int mvy = MV[5];
   const cal_list<int>::t &tex = TEX[0];
   cal_list<int>::t b = comp_block(x, y, n, mvx, mvy);
   return( (cmd == 4) && (detect_skipped(x, y, n) == 0) );
}
bool m_MCadd::guard_mbbuf_tooEmptyInt(void)  const {
   const cal_list<int>::t &b = LAST[0];
   return( (int_buf_count < int_buf_count_ss) );
}
bool m_MCadd::guard_mbbuf_tooEmptyExt(void)  const {
   return( (int_buf_count == int_buf_count_ss) && (ext_buf_count < ext_buf_count_ss) );
}
bool m_MCadd::guard_mbbuf_tooFull(void)  const {
   return( (int_buf_count > int_buf_count_ss || ext_buf_count > ext_buf_count_ss) );
}
bool m_MCadd::guard_mbbuf_justRight(void)  const {
   const cal_list<int>::t &b = LAST[0];
   return( (int_buf_count == int_buf_count_ss) && (ext_buf_count == ext_buf_count_ss) );
}
void m_MCadd::newFrame(void) {
// The action has 0 local variable declarations.
   int cmd = MV[0];
   int x = MV[1];
   int y = MV[2];
   int rounding = MV[3];
   int unused1 = MV[4];
   int unused2 = MV[5];
   if (x != MBwidth || y != MBheight) { 
      int_buf_count_ss = (6 * (((WINSIZE - 1) * x) + WINSIZE)); 
      int_buf_count = (6 * rshift((((WINSIZE - 1) * x) + WINSIZE), 1)); 
      frame_count = (x * y * 6); 
      head_index = (int_buf_count + 5); 
      ext_buf_count_ss = (frame_count + int_buf_count - int_buf_count_ss); 
      MBwidth = x; 
      MBheight = y; 
   }
   rounding_type = rounding; 
   next_x = 0; 
   next_y = 0; 
   next_n = 0; 
   frame_number = (frame_number + 1); 
   if (frame_number == 190) { 
      //println((Frame  + frame_number + , rounding =  + rounding_type));
   }
}
void m_MCadd::docmd_missingBlock(void) {
// The action has 0 local variable declarations.
   int cmd = MV[0];
   int x = MV[1];
   int y = MV[2];
   int n = MV[3];
   int mvx = MV[4];
   int mvy = MV[5];
   //println((Missing block at ( + next_x + , + next_y + , + next_n + )));
   next_block();
   VID[0] = initList((next_n < 4) ? 0 : (128), 64);
}
void m_MCadd::docmd_textureOnly(void) {
// The action has 0 local variable declarations.
   int cmd = MV[0];
   int x = MV[1];
   int y = MV[2];
   int n = MV[3];
   int mvx = MV[4];
   int mvy = MV[5];
   const cal_list<int>::t &tex = TEX[0];
   if (frame_number == 190 && y == 0 && x < 2 && n < 4) { 
      //println((TEX only at ( + next_x + , + next_y + , + next_n + )));
   }
   next_block();
   VID[0] = tex;
}
void m_MCadd::docmd_nothing(void) {
// The action has 0 local variable declarations.
   int cmd = MV[0];
   int x = MV[1];
   int y = MV[2];
   int n = MV[3];
   int mvx = MV[4];
   int mvy = MV[5];
   next_block();
   VID[0] = MBbuf_get(head_index);
}
void m_MCadd::docmd_motionOnly(void) {
// The action has 1 local variable declarations.
   int cmd = MV[0];
   int x = MV[1];
   int y = MV[2];
   int n = MV[3];
   int mvx = MV[4];
   int mvy = MV[5];
   cal_list<int>::t b = comp_block(x, y, n, mvx, mvy);
   next_block();
   VID[0] = b;
}
void m_MCadd::docmd_both(void) {
// The action has 1 local variable declarations.
   int cmd = MV[0];
   int x = MV[1];
   int y = MV[2];
   int n = MV[3];
   int mvx = MV[4];
   int mvy = MV[5];
   const cal_list<int>::t &tex = TEX[0];
   cal_list<int>::t b = comp_block(x, y, n, mvx, mvy);
   next_block();
   VID[0] = combine(tex, b);
}
void m_MCadd::mbbuf_tooEmptyInt(void) {
// The action has 0 local variable declarations.
   const cal_list<int>::t &b = LAST[0];
   MBbuf_add(b);
   int_buf_count = (int_buf_count + 1); 
}
void m_MCadd::mbbuf_tooEmptyExt(void) {
// The action has 0 local variable declarations.
   ext_buf_count = (ext_buf_count + 1); 
}
void m_MCadd::mbbuf_tooFull(void) {
// The action has 0 local variable declarations.
   //println(Unsupported action: mbbuf.tooFull in actor MCadd);
}
void m_MCadd::mbbuf_justRight(void) {
// The action has 0 local variable declarations.
   const cal_list<int>::t &b = LAST[0];
   MBbuf_add(b);
}

   smoc_firing_state process, update; 
          
public:
 m_MCadd(sc_module_name name, int WINSIZE, int MAXMBWIDTH)
 : smoc_actor(name, process), WINSIZE(WINSIZE), MAXMBWIDTH(MAXMBWIDTH), MBwidth(0), MBheight(0), rounding_type(0), next_x(next_x), next_y(next_y), next_n(next_n), int_buf_count(0), int_buf_count_ss(int_buf_count_ss), ext_buf_count(0), ext_buf_count_ss(ext_buf_count_ss), frame_count(frame_count), frame_number(0), head_index(head_index), MBbuf_size((6 * (((WINSIZE - 1) * MAXMBWIDTH) + WINSIZE))), MBbuf_ptr(0), MBbuf(initList(initList(0, 64), MBbuf_size)) {
process.addTransition((MV.getAvailableTokens() >= 6 && 
   guard(&m_MCadd::guard_newFrame)) >> 
   call(&m_MCadd::newFrame) >> process); 
   
process.addTransition((MV.getAvailableTokens() >= 6 && 
   guard(&m_MCadd::guard_docmd_missingBlock)) >> 
   (VID.getAvailableSpace() >= 1) >>
   call(&m_MCadd::docmd_missingBlock) >> update); 
   
process.addTransition((MV.getAvailableTokens() >= 6 && 
   TEX.getAvailableTokens() >= 1 && 
   guard(&m_MCadd::guard_docmd_textureOnly)) >> 
   (VID.getAvailableSpace() >= 1) >>
   call(&m_MCadd::docmd_textureOnly) >> update); 
   
process.addTransition((MV.getAvailableTokens() >= 6 && 
   guard(&m_MCadd::guard_docmd_nothing)) >> 
   (VID.getAvailableSpace() >= 1) >>
   call(&m_MCadd::docmd_nothing) >> update); 
   
process.addTransition((MV.getAvailableTokens() >= 6 && 
   guard(&m_MCadd::guard_docmd_motionOnly)) >> 
   (VID.getAvailableSpace() >= 1) >>
   call(&m_MCadd::docmd_motionOnly) >> update); 
   
process.addTransition((MV.getAvailableTokens() >= 6 && 
   TEX.getAvailableTokens() >= 1 && 
   guard(&m_MCadd::guard_docmd_both)) >> 
   (VID.getAvailableSpace() >= 1) >>
   call(&m_MCadd::docmd_both) >> update); 
   
update.addTransition((LAST.getAvailableTokens() >= 1 && 
   guard(&m_MCadd::guard_mbbuf_tooEmptyInt)) >> 
   call(&m_MCadd::mbbuf_tooEmptyInt) >> process); 
   
update.addTransition((guard(&m_MCadd::guard_mbbuf_tooEmptyExt)) >> 
   call(&m_MCadd::mbbuf_tooEmptyExt) >> process); 
   
update.addTransition((guard(&m_MCadd::guard_mbbuf_tooFull)) >> 
   call(&m_MCadd::mbbuf_tooFull) >> process); 
   
update.addTransition((LAST.getAvailableTokens() >= 1 && 
   guard(&m_MCadd::guard_mbbuf_justRight)) >> 
   call(&m_MCadd::mbbuf_justRight) >> process); 
    
 }
};

