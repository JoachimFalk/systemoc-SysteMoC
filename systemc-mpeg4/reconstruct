import all caltrop.lib.BitOps;

actor reconstruct ( int DCVAL, int LBSIZE )
  List[int] DATA, int FLAGS, int PARAM, int A, int B, int C, int DC ==> List[int] OUT, int OFLAGS :

// Die ersten 64 Werte stellen dar, wie die Originalscanfolge (Zeile für Zeile) be JPEG 
// wieder aus den Zigzac-gescannten Werten regeneriert werden kann. Bsp.: die 5 sagt, dass
// das Bildelement (0. Zeile, 2. Spalte) als 6. Element gescannt wurde (beginnt bei 0)
// Die zweiten und dritten 64 Werte werden gebraucht bei Intra-Frame-Codierung
  List[ List [ int ] ] zigzag = 
  [ [  0,  1,  5,  6, 14, 15, 27, 28,  2,  4,  7, 13, 16, 26, 29, 42,
       3,  8, 12, 17, 25, 30, 41, 43,  9, 11, 18, 24, 31, 40, 44, 53,
      10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60,
      21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63 ],
    [  0,  4,  6, 20, 22, 36, 38, 52,  1,  5,  7, 21, 23, 37, 39, 53,
       2,  8, 19, 24, 34, 40, 50, 54,  3,  9, 18, 25, 35, 41, 51, 55,
      10, 17, 26, 30, 42, 46, 56, 60, 11, 16, 27, 31, 43, 47, 57, 61,
      12, 15, 28, 32, 44, 48, 58, 62, 13, 14, 29, 33, 45, 49, 59, 63 ],
    [  0,  1,  2,  3, 10, 11, 12, 13,  4,  5,  8,  9, 17, 16, 15, 14,
       6,  7, 19, 18, 26, 27, 28, 29, 20, 21, 24, 25, 30, 31, 32, 33,
      22, 23, 34, 35, 42, 43, 44, 45, 36, 37, 40, 41, 46, 47, 48, 49,
      38, 39, 50, 51, 56, 57, 58, 59, 52, 53, 54, 55, 60, 61, 62, 63 ]
  ];

// initList generiert eine Liste mit size Elementen und initialisiert alle Werte mit dem Wert v
  function initList( v, size ) :
    [ v : for i in Integers( 1, size ) ]
  end

// Note: LBSIZE should be 6 * (max_line_width_in_mb + 2 )
// FIXME: lb should be mutable, not assignable.

// lb steht für einen lokalen Puffer, der pro Block 15 Werte speichert, die bei Intra-Frame gebraucht werden.
// lb_in stellt den aktuell zu bearbeitenden Block dar.
// block_count auch; Unterschied: block_count wird bei intra-Frame immer, lb_in modulo LBSIZE erhöht.
  List[ List [ int ] ] lb   := initList( initList( 0, 15 ), LBSIZE  );
  int lb_in       := 0;
  int block_count := 0;

// scan liefert die Liste von 64 Elementen eines Blocks zurück mit der Reihenfolge, die durch 
// die Zigzag-Scan-Ordnung pat gegeben ist
  function scan( d, pat ) :
    [ d [ pat [i] ] : for i in Integers( 0, 63 ) ]
  end

// 1. Aktion: Ist der Guard type<0, dann wird eof ("end of frame") ausgeführt.
// Dabei wird lediglich die Variable block_count wieder of 0 gesetzt.
  eof: action PARAM:[ type, x, y, n ] ==>
  guard
   type < 0
  do
    block_count := 0;
  end

// 2. Aktion: Ist der Guard type=1, dann wird als Ausgangsfolge ein Block erzeugt
// mit der durch zigzag[0] bestimmten Reihenfolge (vgl. JPEG)
// Als Ausgangsflags wird type=1 weitergegeben sowie die Werte q und scaler durchgereicht.
  inter: action PARAM:[ type, x, y, n ], FLAGS:[ac, q, scaler], DATA:[d] ==>
         OUT:[ scan( d, zigzag [0] ) ], OFLAGS:[ 1, q, scaler ]
  guard
   type = 1
  end

// 3. Aktion: getdc setzt den Wert im local buffer des aktuellen Blocks lb_in auf den Wert dc.
  getdc: action DC:[dc] ==>
  do
    lb [ lb_in, 0 ] :=  dc ;
  end

// lb_get_val holt aus dem Puffer buf einen Wert zurück. Dabei bestimmen
// pos: lb_in;
// size: Gesamtgröße von buf;
// seq: sequencer
// head: block_count
// index: Offset
  function lb_get_val( buf, pos, size, seq, head, index ) :
    if seq = 0 then
      DCVAL
    else
      if (pos + ( seq - head )) < 0 then
        buf [pos + ( seq - head ) + size, index ]
      else
        buf [pos + ( seq - head ), index ]
      end
    end
  end

// abs berechnet den Betrag einer Zahl
  function abs( x ) :
    if x < 0 then (-x) else x end
  end

// 4. Aktion: Sehr ähnlich wie Aktion inter, außer dass hier noch die drei Werte 
// A, B, und C verarbeitet werden. Diese bestimmen, ob die Zigzag-Tabelle 1 oder 2 
// verwendet wird. Die Aktion wird ausgeführt, wenn der Guard type=0 ist.
  intra: action PARAM:[ type, x, y, n ], FLAGS:[ ac, q, scaler], DATA:[dd], A:[a], B:[b], C:[c] ==>
         OUT:[ scan( d, zigzag [zsel] ) ], OFLAGS:[ 0, q, scaler ]
  guard
   type = 0
  var
    int dca = lb_get_val( lb, lb_in, LBSIZE, a, block_count, 0 ),
    int dcb = lb_get_val( lb, lb_in, LBSIZE, b, block_count, 0 ),
    int dcc = lb_get_val( lb, lb_in, LBSIZE, c, block_count, 0 ),
    int horiz = abs( dcb - dcc ),
    int vert  = abs( dca - dcb ),
    int zsel = 0,
    int pred,
    int t,
    // lokale Kopie der Eingabedaten (1 Block) erzeugen, da diese hier verändert werden
    // bevor die Ausgabe erfolgt.
    List[int] d = [ dd [i] : for i in Integers(0,63) ]
  do
    if vert < horiz then
      pred := dcc;
      if ac != 0 then
        zsel := 2;
        if c > 0 then
	t := zigzag [2, 1]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 1 ); 
	t := zigzag [2, 2]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 2 ); 
	t := zigzag [2, 3]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 3 ); 
	t := zigzag [2, 4]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 4 ); 
	t := zigzag [2, 5]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 5 ); 
	t := zigzag [2, 6]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 6 ); 
	t := zigzag [2, 7]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 7 ); 
        end
      end
    else
      pred := dca;
      if ac != 0 then
        zsel := 1;
        if a > 0 then
	t := zigzag [1, 8]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 8 ); 
	t := zigzag [1, 16]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 9 ); 
	t := zigzag [1, 24]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 10 ); 
	t := zigzag [1, 32]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 11 ); 
	t := zigzag [1, 40]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 12 ); 
	t := zigzag [1, 48]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 13 ); 
	t := zigzag [1, 56]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 14 ); 
        end
      end
    end
    d[0] := (d[0]  * scaler ) + ( ( pred + rshift(scaler,2) ) / scaler ) * scaler ;

    // Hier werden block_count erhöht und lb_in modulo LBSIZE; 
    block_count := block_count + 1;
    lb_in := lb_in + 1;
    if lb_in >= LBSIZE then
      lb_in := 0;
    end
    // Zuletzt werden die erste Zeile und erste Spalte des nächsten lokalen Puffers auf die Werte 
    // des letzten Blocks gesetzt.
    lb [lb_in] := [ d [zigzag [zsel, i]] : for i in [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 24, 32, 40, 48, 56 ] ] ;
  end

// Anfangszustand: read. Von hier aus geht es nach read über die 1. Aktion eof (falls guard type<0),
// bzw. ebenfalls nach read über Aktion 2, (falls guard type=1) bzw. nach Zustand wait (Aktion3)
// (falls guard type=0).
// Von Zustand wait geht es immer wieder zurück in den Zustand read, sobald die 3. Aktion
// (getdc) ausgeführt wurde.
  schedule fsm read :
    read( eof   ) --> read;
    read( inter ) --> read;
    read( intra ) --> wait;
    wait( getdc ) --> read;
  end
end


/*********************************************************************/
class reconstruct: publich smoc_actor {
public:
  smoc_port_in<int> DATA;
  smoc_port_in<int> FLAGS;
  smoc_port_in<int> PARAM;
  smoc_port_in<int> A, B, C, DC;
  smoc_port_out<int> OUT;
  smoc_port_out<int> OFLAGS;

private:
  int zigzag[][] = {{
       0,  1,  5,  6, 14, 15, 27, 28,  2,  4,  7, 13, 16, 26, 29, 42,
       3,  8, 12, 17, 25, 30, 41, 43,  9, 11, 18, 24, 31, 40, 44, 53,
      10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60,
      21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63 },
    {  0,  4,  6, 20, 22, 36, 38, 52,  1,  5,  7, 21, 23, 37, 39, 53,
       2,  8, 19, 24, 34, 40, 50, 54,  3,  9, 18, 25, 35, 41, 51, 55,
      10, 17, 26, 30, 42, 46, 56, 60, 11, 16, 27, 31, 43, 47, 57, 61,
      12, 15, 28, 32, 44, 48, 58, 62, 13, 14, 29, 33, 45, 49, 59, 63 },
    {  0,  1,  2,  3, 10, 11, 12, 13,  4,  5,  8,  9, 17, 16, 15, 14,
       6,  7, 19, 18, 26, 27, 28, 29, 20, 21, 24, 25, 30, 31, 32, 33,
      22, 23, 34, 35, 42, 43, 44, 45, 36, 37, 40, 41, 46, 47, 48, 49,
      38, 39, 50, 51, 56, 57, 58, 59, 52, 53, 54, 55, 60, 61, 62, 63 }
  };

  int lb[15][LBSIZE];
  int lb_in = 0;
  int block_count = 0;

  void initList (int v) {
      int i,j;
      for (i=0; i < 15; i++)
        for (j=0; j < LBSIZE; j++) 
             lb[i][j] = v;
  }

  void function scan (int res[], int d[], int pat[]) {
      int i;
      for (i=0; i <= 63; i++)
         res[i] = d[pat[i]];
  }

  int lb_get_val (int buf[][], int pos, int size, int seq, int head, int index) {
      if (seq == 0) return (DCVAL);
      else {
         if ( pos + (seq - head) ) < 0 return (buf[pos + (seq - head) + size][index]);
         else return (buf[pos + (seq - head)][index]); 
      }
  }

  int abs(int x) {
      if (x < 0) return (-x);
      else return (x);
  }  

  bool guard1() {return(PARAM[0] < 0); /* PARAM[0] = type */}
  bool guard2() {return(PARAM[0] == 1);}
  bool guard3() {return(PARAM[0] == 0);}

  // Hier kommen die 4 Aktionen eof, inter, intra und getdc

  void eof()   {block_count = 0};

  void inter() {int i;
                // Nun Ausgänge erzeugen:
                // Hier muss noch res als Ergebnisvektor alloziert werden;
                // Oder sollte man res in der Funktion scan allozieren und den Vektor zurückgeben?
                scan(&res, &d, &zigzag[0]);
                for (i=0, i<63; i++)
                 OUT[i] = res[i];
                OFLAGS[0] = 1;
                OFLAGS[1] = q;
                OFLAGS[2] = scaler;}

  void intra() {int i, j, horiz, vert, dca, dcb, dcc;
                int zsel;
                int pred;
                int t;
                int d[64];
                for (i=0; i <= 63; i++)
                    d[i] = DD[i];
                dca = lb_get_val(&lb, lb_in, LBSIZE, A, block_count, 0);
                dcb = lb_get_val(&lb, lb_in, LBSIZE, B, block_count, 0);
                dcc = lb_get_val(&lb, lb_in, LBSIZE, C, block_count, 0);
                horiz = abs( dcb - dcc );
                vert = abs( dca - dcb );
                zsel = 0;
 
                // DO-part
                if (vert < horiz) { 
		       pred = dcc;
                   if (ac != 0) {
                     zsel = 2;
                     if (c > 0) {
				t = zigzag[2, 1]; d[t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, C, block_count, 1 ); 
				t = zigzag[2, 2]; d[t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, C, block_count, 2 ); 
				t = zigzag[2, 3]; d[t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, C, block_count, 3 ); 
				t = zigzag[2, 4]; d[t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, C, block_count, 4 ); 
				t = zigzag[2, 5]; d[t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, C, block_count, 5 ); 
				t = zigzag[2, 6]; d[t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, C, block_count, 6 ); 
				t = zigzag[2, 7]; d[t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, C, block_count, 7 ); 
                     }
			}	
                }
                else {
                   pred = dca;
                   if (ac != 0) {
                     zsel = 1;
                     if (a > 0) {
                      	t = zigzag [1, 8]; d [t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, A, block_count, 8 ); 
				t = zigzag [1, 16]; d [t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, A, block_count, 9 ); 
				t = zigzag [1, 24]; d [t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, A, block_count, 10 ); 
				t = zigzag [1, 32]; d [t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, A, block_count, 11 ); 
				t = zigzag [1, 40]; d [t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, A, block_count, 12 ); 
				t = zigzag [1, 48]; d [t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, A, block_count, 13 ); 
				t = zigzag [1, 56]; d [t] = d[t] + lb_get_val( lb, lb_in, LBSIZE, A, block_count, 14 );
                     }
                   }
                }
                
                // In folgender Berechnung soll / eine Integer-Division sein.
                d[0] = (d[0] * scaler) + (((pred + (scaler >> 2)) / scaler) * scaler);

                block_count = block_count + 1;
                lb_in = lb_in + 1;
                if (lb_in >= LBSIZE)
                    lb_in = 0;
                for (i=0; i <= 7; i++)
                   lb[i][lb_in] = d[zigzag[zsel][i]];
                for (i=1; i <= 7; i++)
                   lb[i][lb_in] = d[zigzag[zsel][8 * i]];
                // Ende DO-part
  
                // Nun Ausgänge erzeugen:
                // Hier muss noch res als Ergebnisvektor alloziert werden;
                // Oder sollte man res in der Funktion scan allozieren und den Vektor zurückgeben?
                scan(&res, &d, &zigzag[zsel]);
                for (i=0; i<63; i++)
                  OUT[i] = res[i];
                OFLAGS[0] = 0; 
                OFLAGS[1] = q; 
                OFLAGS[2] = scaler;}

  void getdc() {lb[lb_in][0] = dc;}
  
  smoc_firing_state read, wait;

public:
  reconstruct(sc_module_name name, int DCVAL, int LBSIZE)
    : smoc_actor(name, read), DCVAL(DCVAL), LBSIZE(LBSIZE) {
    read = (FLAGS.getAvailableTokens() >= 4 &&
            guard(&reconstruct::guard1) ) >>
            call(&reconstruct::eof)       >> read 
          | (DATA.getAvailableTokens() >= 64 &&
		FLAGS.getAvailableTokens() >= 3 &&
		PARAM.getAvailableTokens() >= 4 && 
            guard(&reconstruct::guard2) ) >>
		call(&reconstruct::inter)   >> read
          | DATA.getAvailableTokens() >= 64 &&
		FLAGS.getAvailableTokens() >= 3 &&
		PARAM.getAvailableTokens() >= 4 && 
            guard(&reconstruct:guard3) ) >> 
		call(&reconstruct::intra)   >> wait;
    wait = (DC.getAvailableTokens() >= 1) >>
            call(&reconstruct::getdc)     >> read;
  }
};
