\chapter{Syntax}

This section presents the syntax defined by the \SysteMoC{} library for model-based designs.
A complete application is modeled \SysteMoC{} by a set of \emph{actors} and their interconnection using \emph{channels}. 
The overall model is therefore a network of actors and channels.
Actors are objects which execute concurrently.
An actor $a$ can only communicate with other actors through its sets of \emph{actor input and output ports} denoted $a.I$ and $a.O$, respectively.
The actor ports are connected with each other via a communication medium called \emph{channel}.
The basic entity of data transfer is regulated by the notion of \emph{tokens} which are transmitted via these channels.

\section{Network Graph}
The creation of a \SysteMoC{} model can be roughly divided into two subtasks:
(i) The creation of a \emph{network graph} for the design, e.g., as displayed in Figure~\ref{fig:ng-sqrroot} for an approximative square root algorithm, and
(ii) the creation of all \emph{actor classes} needed by the design, e.g., \code{SqrLoop} in Figure~\ref{fig:actor-sqrloop}.
The network graph is composed of \emph{actor instances} of these actor classes which are connected via \emph{channels}.
Before defining a network graph formally, an example is given.

\begin{example}\label{ex:systemoc-networkgraph}%
The approximative square root algorithm in Figure~\ref{fig:ng-sqrroot} is stimulated by an infinite sequence of input token values generated by the actor \code{Src}.
These input token values are transported via channel $c_1$ to the actor \code{SqrLoop} which implements the error bound checking of the approximation algorithm.
If the error bound is not satisfied, the input value will be send to actor \code{Approx} via channel $c_2$. 
This will eventually result in a new better approximated square root value in channel $c_4$.
This iteration repeats until the error bound is satisfied and the approximation result is forwarded via channel $c_5$ to the actor \code{Sink}.
\begin{figure}
\centering
\resizebox{\textwidth}{!}{\input{ng-sqrroot-fig.tex}}
\caption{\label{fig:ng-sqrroot}%
The \emph{network graph} displayed above implements Newton's iterative algorithm for calculating the square roots of an infinite input sequence generated by the actor \code{Src}.
The square root values are generated by Newton's iterative algorithm actor \code{SqrLoop} for the error bound checking and actor \code{Approx} to perform an approximation step.
After satisfying the error bound, the result is transported to the actor \code{Sink}.}
\end{figure}
\end{example}

In \SysteMoC{}, a \emph{network graph} is represented as a C++ class derived from the base class \code{smoc\_graph}, e.g., as seen in the following code for the above square root approximation algorithm example:
{\small
\begin{verbatim}
// Declare network graph class SqrRoot
class SqrRoot: public smoc_graph {
protected:
  // Actors are C++ objects
  Src      src;     
  SqrLoop  sqrloop; 
  Approx   approx;  
  Sink     sink;    
public:
  // Constructor of network graph class assembles network graph
  SqrRoot( sc_module_name name )
    : smoc_graph(name),
      src("src", 50),
      sqrloop("sqrloop"),
      approx("approx"),
      sink("sink") {
    // The network graph is instantiated in the constructor
    // src.o1 -> sqrloop.i2 using FIFO standard size
    connectNodePorts(src.o1, sqrloop.i2, smoc_fifo<double>());
    // sqrloop.o1 -> approx.i2 using FIFO standard size
    connectNodePorts(sqrloop.o1, approx.i2, smoc_fifo<double>());
    // approx.o1 -> approx.i1 using FIFO standard size and
    // an initial sequence of 2
    connectNodePorts(approx.o1,  approx.i1,
                     smoc_fifo<double>() << 2);
    // approx.o2 -> sqrloop.i1 using FIFO standard size
    connectNodePorts(approx.o2, sqrloop.i1, smoc_fifo<double>());
    // sqrloop.o2 -> sink.i1 using FIFO standard size
    connectNodePorts(sqrloop.o2, sink.i1, smoc_fifo<double>());
  }
};
\end{verbatim}}

The actors of the network graph in Figure~\ref{fig:ng-sqrroot} are member variables.
They can be parameterized via common C++ syntax in the constructor of the \emph{network graph class}, e.g., \code{src("src", 50)}.
The connections of these actors via channels are assembled in the constructor of the network graph class, e.g., \code{connectNodePorts (src.o1, sqrloop.i1, smoc\_fifo<double>())}.
Here, queues with FIFO semantics are used for the communication.

The queues are created by the \code{connectNodePorts($o$, $i$[, param])} function which creates a queue with FIFO semantics between output port $o$ and input port $i$.
The optional parameter \code{param} is used to further parameterize the created FIFO channel, e.g., \code{smoc\_fifo<double>(1) $<<$ 2} is used to create a FIFO channel for \code{double} tokens of depth one with an initial token of value two.
More formally, we can derive the following definition for a \emph{network graph}:

\begin{definition}[Network graph]\label{def:network-graph}
A \emph{network graph} is a graph $g=(A,C,E)$, where
\begin{itemize}
\item $A$ is a finite set of \emph{actors}
\item $C$ is a finite set of \emph{channels}
\item $E$ is a finite set of \emph{edges}, with $E \subseteq (C \times A.I) \cup (A.O \times C)$\footnote{
 $A.I = \bigcup{}_{a \in A} a.I$ and $A.O = \bigcup{}_{a \in A} a.O$ denote the sets of all input ports, respectively all output ports, of all actors in the network graph.
}.
\end{itemize}
\end{definition}

Each actor $a \in A$ may only communicate with other actors through its dedicated actor input ports $a.I$ and actor output ports $a.O$.
Furthermore, the set of all actor input and actor output ports of all actors in the network graph is given by $A.\mathcal{P} = A.I \cup A.O$.\footnote{We use the `$.$'-operator, e.g., $a.\mathcal{P}$, for member access, e.g., $\mathcal{P}$, of tuples whose members have been explicitly named in their definition, e.g., $a \in A$ from Definition~\ref{def:actor}.
  Moreover, this member access operator has a trivial pointwise extension to sets of tuples, e.g., $A.\mathcal{P} = \bigcup{}_{a \in A} a.\mathcal{P}$, which is also used throughout this document.}
Actors are discussed in more detail in Section~\ref{sec:actor}.
A presentation of different channels supported by \SysteMoC{} is given in Section~\ref{sec:channel}.
Finally, the execution semantics are discussed in Chapter~\ref{chap:semantics}.

%
%
\section{Actor \label{sec:actor}}

\begin{definition}[Actor]\label{def:actor}
An \emph{actor} is a tuple $a=(P,S,F,R,m_\mathrm{init})$, where
\begin{itemize}
\item $P$ is a finite set of \emph{ports}, partitioned into \emph{input ports} $I$ and \emph{output ports} $O$ (i.e., $P=I\cup O$, with $I\cap O=\emptyset$) 
\item $S$ is a finite set of \emph{variables}
\item $F$ is a finite set of \emph{functions}, partitioned into \emph{action functions} $F_\mathrm{actions}$ and \emph{guard functions} $F_\mathrm{guards}$
\item $R$ is the \emph{actor's FSM}
\item $m_\mathrm{init}$ is an \emph{initial assignment} to the variables in $S$, i.e., $m_\mathrm{init} : S \rightarrow \mathbb{D}$.
\end{itemize}
\end{definition}

\marginpar{TODO}
Describe following points within the running example (not within own subsection):
\begin{itemize}
\item Actor parameter
\item Function parameter
\end{itemize}

\subsection{Ports}

\subsection{Variables}

\subsection{Functions}

\subsection{Actor finite state machine}

\begin{definition}[Actor FSM]
Let $g=(A,C,E)$ be a network graph.
The \emph{Actor FSM} $a.R=(T,Q,q_0)$ of an actor $a=(P,S,F,R,m_\mathrm{init}) \in A$ is a tuple, where
\begin{itemize}
\item $T$ is a finite set of \emph{transitions}
\item $Q$ is a finite set of \emph{states}
\item $q_0$ is an \emph{initial state}, with $q_0\in Q$.
\end{itemize}
\end{definition}

\begin{definition}[Transition]
Let $a=(P,S,F,R,m_\mathrm{init})$ be an actor, with actor FSM $R=(T,Q,q_0)$.
A \emph{transition} $t=(q,k,f_\mathrm{action},q')\in T$ is a tuple, where
\begin{itemize}
\item $q$ is the current state, with $q \in Q$
\item $k$ is a boolean function, called \emph{activation pattern}
\item $f_\mathrm{action}$ is an action function, with $f_\mathrm{action}\in F_\mathrm{actions}$
\item $q'$ is the next state, with $q' \in Q$.
\end{itemize}
\end{definition}

%
%
\section{Channel \label{sec:channel}}
