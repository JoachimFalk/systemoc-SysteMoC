\chapter{\SysteMoC{} - syntax}\label{sec:systemoc-syntax}

A complete application is modeled by a set of actors and their 
interconnection using channels. The overall model is therefore 
a network of actors and channels.

\section{Network graph}\label{sec:network-graph}

The creation of a \SysteMoC{} design can be roughly divided into two subtasks:
(i) The creation of a \emph{network graph} for the design, e.g., as displayed in Figure~\ref{fig:ng-sqrroot} for an approximative square root algorithm, and
(ii) the creation of all \emph{actor classes} needed by the design, e.g., \code{SqrLoop} in Figure~\ref{fig:actor-sqrloop}.
The network graph is composed of \emph{actor instances} of these actor classes, e.g., $a_1$ - $a_5$, which are connected via \emph{channels}.

% Der Aufbau einer Anwendung in \SysteMoC{} lässt sich grob in zwei Teilaufgaben untergliedern: (i) Die Definition der \emph{Aktorbeschreibung} und (ii) die Instantiierung und Verknüpfung dieser Aktorbeschreibungen mittels Kanälen zu einem \emph{Netzwerkgraphen}.
% in Beispiel einer Aktorbeschreibung ist in den Abbildungen \ref{systemoc-actor-def} bis \ref{systemoc-bthchk-fsm} dargestellt.
% Diese Beschreibung wird anschließend im Netzwerkgraph des InfiniBand-HCA, dargestellt in Abbildung \ref{fig:ng-sqrroot}, für die \emph{Aktorinstanz} $a_{11}$ verwendet.

\begin{figure}[h]
\centering
%\resizebox{\textwidth}{!}{\input{ng-sqrroot-fig.tex}}
%\includegraphics[width = 4in]{ng-sqrroot}
\input{ng-sqrroot-fig.tex}
\caption{\label{fig:ng-sqrroot}%
The \emph{network graph} displayed above implements Newton's iterative algorithm for calculating the square roots of an infinite input sequence generated by the \code{Src} actor $a_1$. The square root values are generated by Newton's iterative algorithm \code{SqrLoop} actor $a_2$ for the error bound checking and $a_3$ - $a_4$ to perform an approximation step.
After satisfying the error bound, the result is transported to the \code{Sink} actor $a_5$.}
\end{figure}

The approximative square root algorithm in Figure~\ref{fig:ng-sqrroot} is stimulated by an infinite sequence of input token values generated by the \code{Src} actor $a_1$.
These input token values are transported via channel $c_1$ to the \code{SqrLoop} actor $a_2$ which implements the error bound checking of the approximation algorithm.
If the error bound is not satisfied, the input value will be send to actor $a_3$ via channel $c_2$. This will eventually result in a new better approximated square root value in channel $c_5$.
This iteration repeats until the error bound is satisfied and the approximation result
is forwarded via channel $c_6$ to the \code{Sink} actor $a_5$.

In an actor-oriented design \cite{agha97abstracting:1997}, a model of computation \cite{embsft:2002} defines
the interaction policy between actors.
Actors are objects which execute concurrently.
An actor $a$ can only communicate with other actors through its sets of \emph{actor input and output ports} denoted $a.I$ and $a.O$, respectively.
The actor ports are connected with each other via a communication
medium called \emph{channel}.
The basic entity of data transfer is regulated by the notion of \emph{tokens} which are transmitted via these channels.
See Figure~\ref{fig:ng-sqrroot} for an example of a \emph{network graph}, where $c_1$ - $c_6$ denote \emph{FIFO} channels.

Actors are connected to other actors via channels.
These connections are encoded in the \emph{network graph}.
In \SysteMoC{}, a \emph{network graph} is represented as a C++ class derived from the base class \code{smoc\_graph}, e.g., as seen in the following code for the above square root 
approximation algorithm example:

\begin{example}\label{ex:systemoc-networkgraph}%
Network graph corresponding to Figure~\ref{fig:ng-sqrroot}:
\begin{verbatim}
// Declare network graph class SqrRoot
class SqrRoot: public smoc_graph {
protected:
  // Actors are C++ objects
  Src      src;     // Actor a1
  SqrLoop  sqrloop; // Actor a2
  Approx   approx;  // Actor a3
  Dup      dup;     // Actor a4
  Sink     sink;    // Actor a5
public:
  // Constructor of network graph class assembles network graph
  SqrRoot( sc_module_name name )
    : smoc_graph(name),
      src("a1", 50),
      sqrloop("a2"),
      approx("a3"),
      dup("a4"),
      sink("a5") {
    // The network graph is instantiated in the constructor
    // a1.o1 -> a2.i1 using FIFO standard size
    connectNodePorts(src.o1,     sqrloop.i1);
    // a2.o1 -> a3.i1 using FIFO standard size
    connectNodePorts(sqrloop.o1, approx.i1);
    // a3.o1 -> a4.i1 using FIFO size 1
    connectNodePorts(approx.o1,  dup.i1,
                     smoc_fifo<double>(1) );
    // a4.o1 -> a3.i2 using FIFO standard size and
    // an initial sequence of 2
    connectNodePorts(dup.o1,     approx.i2,
                     smoc_fifo<double>() << 2 );
    // a4.o2 -> a2.i2 using FIFO standard size
    connectNodePorts(dup.o2,     sqrloop.i2);
    // a2.o2 -> a5.i1 using FIFO standard size
    connectNodePorts(sqrloop.o2, sink.i1);
  }
};
\end{verbatim}
\end{example}

% Der Netzwerkgraph wird in einer von \code{smoc\_graph} abgeleiteten Klasse,
% im Folgenden als \emph{Graphenklasse} bezeichnet, zusammengesetzt.
% Die Aktoren des Netzwerkgraph, z.B. $a_{1}$ - $a_{17}$ in Abbildung \ref{fig:ng-sqrroot}
% auf Seite \pageref{fig:ng-sqrroot}, werden in dieser Klasse als Klassenvariablen
% deklariert und im Konstruktor der Graphenklasse parametrisiert und verknüpft, z.B. für die Aktoren
% $a_{10}$, $a_{11}$, $a_{12}$ und $a_{15}$ in Beispiel~\ref{ex:systemoc-networkgraph} dargestellt.

% Ausschnitt aus der Graphenklasse zur Verknüpfung der
% in Abbildung \ref{fig:ng-sqrroot} auf Seite \pageref{fig:ng-sqrroot}
% dargestellten Aktoren.
% Die Aktoren werden als Klassenvariablen deklariert, z.B. \code{mBthChk},
% und im Konstruktor parametrisiert und mittels Kanälen untereinander verbunden.
% Die Verbindungen werden hierbei mittels der \code{connectNodePorts} Funktion
% erstellt. Welche als Parameter den Ausgangsport und Eingangsport von verschiedenen
% Aktoren erhält um diese mittels eines FIFOs zu verbinden.
% Als optionales dritter Parameter der Funktion kann der FIFO mittels
% des '\code{smoc\_fifo<MsgType>(FifoSize) << InitialTokens << ...}'
% Syntaxes genauer parametrisiert werden.

%This infrastructure is separated into \emph{network graph} and \emph{channel kind}.

%In our proposed methodology, the specification is more
%detailed than in actor-oriented design in a way that an actor is divided into
%its \emph{node functionality} and its \emph{firing rules}. The
%type of firing rules an actor can show is dependent on its \emph{node interface}.

% The data values, which are communicated over the channels
% are abstracted. Thus, these data are called \emph{tokens} regardless
% of their type or value.

%However, these definition is not sufficient for distinguishing MoCs.
%The communication infrastructure used by actors must be considered as well.

The actors of the network graph, e.g., $a_1$ - $a_5$ in Figure~\ref{fig:ng-sqrroot}, are member variables.
They can be parameterized via common C++ syntax in the constructor of the \emph{network graph class}, e.g., \code{src("a1", 50)}.
The connections of these actors via FIFO channels are assembled in the constructor of the network graph class, e.g., \code{connectNodePorts (src.o1, sqrloop.i1)} to connect $a_1.o_1$ to $a_2.i_1$.
The FIFO channels are created by the \code{connectNodePorts($o$, $i$[, param])} function which creates a FIFO channel between output port $o$ and input port $i$.
The optional parameter \code{param} is used to further parameterize the created FIFO channel, e.g., \code{smoc\_fifo<double>(1) $<<$ 2} is used to create a FIFO channel for \code{double} tokens of depth one with an initial token of value two.
More formally, we can derive the following definition for a \emph{network graph}:

\begin{definition}[Network graph]\label{def:network-graph}
A \emph{(general) network graph} is a directed bipartite graph $g=(A,C,P,E)$ containing
a set of actors $A$,
a set of channels $C$, 
a channel parameter function $P: C \to \mathbb{N}_\infty \times V^*$ which
associates with each channel $c \in C$ its buffer size $n \in \mathbb{N}_\infty = \{1,2,3,\ldots\infty\}$,
and possibly also a non-empty sequence $\mathbf{v} \in V^*$ of initial tokens\footnote{
  We use the $V^* = \bigcup_{n \in \mathbb{N} \cup \{0\}} V^n$ notation to denote the set of all \emph{tuples} of $V$ also called \emph{finite sequences} of $V$.\\
  Furthermore, we will use $V^{**} = \bigcup_{n \in \mathbb{N}_\infty \cup \{0\}} V^n$ to denote the set of all finite and infinite \emph{sequences} of $V$ \cite{Lee98}.
},
and finally a set of directed edges $E \subseteq (C \times A.I) \cup (A.O \times C)$,
where $A.I = \bigcup{}_{a \in A} a.I$ and $A.O = \bigcup{}_{a \in A} a.O$ denote the sets of \emph{all actor input ports} and \emph{all actor output ports} in the network graph, respectively.
\end{definition}

Each actor $a \in A$ may only communicate with other
actors through its dedicated actor input ports $a.I$ and actor output ports $a.O$.
Furthermore, the set of all actor input and actor output ports of all actors in
the network graph is given by $A.\mathcal{P} = A.I \cup A.O$.\footnote{
  We use the `$.$'-operator, e.g., $a.\mathcal{P}$, for member access, e.g., $\mathcal{P}$, of tuples whose members have been explicitly named in their definition, e.g., $a \in A$ from Definition~\ref{def:actor}.
  Moreover, this member access operator has a trivial pointwise extension to sets of tuples, e.g., $A.\mathcal{P} = \bigcup{}_{a \in A} a.\mathcal{P}$, which is also used throughout this document.
}
However, the preceding definition still allows multiple readers and writers per FIFO channel.
Therefore, we define a more restricted form of network graphs called \emph{non-conflicting network graph} which allows only \emph{point-to-point} connections per channel.

%  However the network graph defined above is still too general. A more
%  constrained form called \emph{nonconflicting network graph} can be
%  defined which still satisfies the requirements for the MoCs presented
%  in this paper. An example of a nonconflicting network graph is shown
%  in Figure~\ref{fig:ng-moc}.
%
\begin{definition}[Non-conflicting network graph]\label{def:noconflicting-network-graph}
  A \emph{non-conflicting network} \emph{graph} is a network graph where
  the edges are further constraint such that exactly one edge is incident to each actor port and the in-degree and out-degree of each channel in the graph is exactly one,
  i.e., $\forall{p \in A.\mathcal{P}}: |((\{p\} \times C) \cup (C \times \{p\})) \cap E| = 1$ and
  $\forall{c \in C}: |(\{c\} \times A.I) \cap E| = 1 \wedge
                     |(A.O \times \{c\}) \cap E| = 1$.
\end{definition}

In the following, we assume that we are dealing only with non-conflicting network graphs, 
thus allowing us to simply omit the term non-conflicting.
% The \emph{channel kind} defines the communication semantics of a channel.
% Since the communication semantics are not influenced by the
% data type communicated, the actual \emph{type} of a communication
% channel is derived from the channel kind by parameterizing it with
% the actual data type. Examples for channel kinds are
% FIFO channels and a rendezvous channels. Channels are used to
% transport data values in form of so-called \emph{tokens}.

\section{Actor classes}

An \emph{actor} can be thought of as an object which maps sequences of token values on its input ports to sequences of token values on its output ports.
In \SysteMoC{}, each actor is represented as an instance of an \emph{actor class} which is derived from the C++ base class \code{smoc\_actor}, e.g., as seen in the following example for the SqrLoop actor class.

%\newpage
\begin{example}\label{ex:systemoc-sqrloop-actor-def}%
Definition of the \code{SqrLoop} actor class:
\begin{verbatim}
class SqrLoop
  // All actor classes must be derived
  // from the smoc_actor base class
  : public smoc_actor {
public:
  // Declaration of input and output ports
  smoc_port_in<double>  ...
private:
  // Declaration of the actor functionality
  // via member variables and member functions
  ...
  
  // Declaration of states for the firing FSM
  smoc_firing_state start;
  ...
public:
  // Constructor responsible for building the
  // firing FSM and initializing the actor
  SqrLoop(sc_module_name name)
    : smoc_actor( name, start ) {
    ...
  }
};
\end{verbatim}
\end{example}

Accordingly, each \emph{actor instance}, in the following simply called \emph{actor}, is a C++ object of its corresponding actor class. As can be seen in the above code,
each definition of an actor class can be subdivided into three parts:
  (i) Declaration of the actor \emph{input ports} and \emph{output ports},
  (ii) declaration of the actor \emph{functionality}, and
  (iii) declaration of the actor \emph{communication behavior}, encoded by 
  an explicit \emph{firing FSM}.
More formally, we can derive the following definitions:

\begin{definition}[Actor]\label{def:actor}
An actor is a tuple $a=(\mathcal{P},\mathcal{F},\mathcal{R})$ containing
a set of \emph{actor ports} $\mathcal{P} = I \cup O$ partitioned into \emph{actor input ports} $I$ and \emph{actor output ports} $O$,
the \emph{actor functionality} $\mathcal{F}$ and the \emph{firing FSM} $\mathcal{R}$.
\end{definition}

The \emph{actor state} $q = (q_\mathrm{func}, q_\mathrm{firing})$ is combined from the state stored in the actor functionality $q_\mathrm{func} \in \mathcal{F}.Q_\mathrm{func}$ and the state of the firing FSM $q_\mathrm{firing} \in \mathcal{R}.Q_\mathrm{firing}$, i.e., $q \in Q = \mathcal{F}.Q_\mathrm{func} \times \mathcal{R}.Q_\mathrm{firing}$.
The three parts of an actor can also be seen in Figure~\ref{fig:actor-sqrloop} which shows a
graphical representation the actor defined in the Examples~\ref{ex:systemoc-sqrloop-actor-def} - \ref{ex:systemoc-sqrloop-fsm-def}.
In the following, the steps to construct these three parts will be explained in detail.

\begin{figure}[t]
\centering
\resizebox{\textwidth}{!}{\input{actor-sqrloop-fig.tex}}
%\includegraphics[width = 5in]{actor-sqrloop}
\caption{\label{fig:actor-sqrloop}%
Visual representation of the \code{SqrLoop} actor $a_2$ used in the network graph displayed in Figure~\ref{fig:ng-sqrroot}.
The \code{SqrLoop} actor is composed of \emph{input ports} and \emph{output ports}, its \emph{functionality}, and the \emph{firing FSM} determining the communication behavior of the actor.}
\end{figure}

\subsection{Actor input and output ports}\label{sec:actor-ports}

An actor may only communicate with other actors via tokens passing 
from output ports to input ports via channels
as can be seen in Figure~\ref{fig:ng-sqrroot} where actor $a_2$ is connected via its input ports $a_2.I = \{i_1, i_2\}$ and output ports $a_2.O = \{o_1, o_2\}$
to all other actors in the network graph.
The port declaration must be located in the \emph{public} part of the actor class to allow 
to connect all these actors together in a network graph description.
An example of a port declaration can be seen in the example below.

\begin{example}\label{ex:systemoc-ports-def}%
Port declaration for the \code{SqrLoop} actor class:
\begin{verbatim}
class SqrLoop: public smoc_actor {
public:
  // Declaration of input and output ports
  smoc_port_in<double>  i1, i2;
  smoc_port_out<double> o1, o2;
private:
  ...
};
\end{verbatim}
\end{example}

Please note that the usage of normal \code{sc\_fifo} channels as provided by the SystemC language with \code{sc\_fifo\_in} and \code{sc\_fifo\_out} ports would not allow to separate actor functionality and communication behavior because these ports allow \emph{destructive reads} and \emph{non-destructive writes}.
This would enable the actor functionality to actually consume and produce tokens contradicting the separation of these two aspects.
For this reason, the \SysteMoC{} library provides its own input and output port declarations \code{smoc\_port\_in} and \code{smoc\_port\_out}.
These use the same concept of template parameters as standard SystemC ports, e.g., \code{sc\_fifo\_in}, to specify the type of token communicated.
%For example, to specify a port which communicates tokens with values of type \code{double}, the declaration is \code{smoc\_port\_in$<$double$>$}.

\subsection{Actor functionality}\label{sec:actor-functionality}
The actor functionality is represented by member variables and member functions of the actor.
These functions manipulate the so-called \emph{functionality state} 
reflected by the current values of the set of member variables of the actor.
Some member functions of an actor are referenced by the firing FSM
to calculate token values to be produced on the output ports.
These member functions are called \emph{actor actions} or \emph{actions} for short, e.g.,
\code{copyStore} in Example~\ref{ex:systemoc-functionality-def}.
They can manipulate the functionality state.
Other member functions are referenced by the firing FSM to decide if
transitions in the FSM are enabled an can be taken.
These member functions are called \emph{actor guards} or \emph{guards} for short, e.g.,
\code{check} in Example~\ref{ex:systemoc-functionality-def},
and must not manipulate the functionality state.
Therefore, these member functions are required to be declared as \emph{const member functions}.

\begin{example}\label{ex:systemoc-functionality-def}%
Declaration of actor functionality:
\begin{verbatim}
class SqrLoop: public smoc_actor {
public:
  ...
private:
  // Declaration of the actor functionality
  // via member variables and member functions
  double tmp_i1;
  
  // action functions triggered by the
  // FSM declared in the constructor
  void copyStore()  { o1[0] = tmp_i1 = i1[0];  }
  void copyInput()  { o1[0] = tmp_i1;          }
  void copyApprox() { o2[0] = i2[0];           }
  
  // and guards only used by the firing FSM
  bool check() const
    { return fabs(tmp_i1-i2[0]*i2[0]) < BOUND; }
  ...
};
\end{verbatim}
\noindent The actor has four member functions including three actions (\code{copyStore()}, 
\code{copy} \code{Input()}, and \code{copyApprox()}), one guard (\code{check()}) 
as well as one member variable \code{tmp\_i1}.
\end{example}

%The \emph{functionality state} of an actor is stored in its member variables and
%the \emph{actor functionality} is distributed over its \emph{member functions}.
%These member function can be divided into \emph{actions}, \emph{guards} and \emph{helper functions}.
%The actions of an actor are used to calculate token values to be procduced on its output ports.
%These functions can manipulate the functionality state.
%Whereas the \emph{guards} are only used to decide if a transition in the firing FSM is enabled. 
%These functions must not manipulate the functionality state.
%Both actions and guards can use helper functions to accomplish their purpose.

\begin{definition}[Actor functionality]\label{def:actor-functionality}
  The \emph{actor functionality} of an actor $a \in A$ is a tuple $a.\mathcal{F} = (F,Q_\mathrm{func},q_{_0\mathrm{func}})$ containing
  a set of \emph{functions} $F = F_\mathrm{action} \cup F_\mathrm{guard}$ partitioned into \emph{actions} and \emph{guards},
  a set of \emph{functionality states} $Q_\mathrm{func}$ (possibly infinite), and
  an \emph{initial functionality state} $q_{_0\mathrm{func}} \in Q_\mathrm{func}$.
\end{definition}

\begin{example}
For the example introduced in Example~\ref{ex:systemoc-functionality-def}, we obtain 
the following description:
\begin{eqnarray}
F_\mathrm{action}   & = & \{f_\mathtt{copyStore}, f_\mathtt{copyInput}, f_\mathtt{copyApprox}\} \nonumber \\
F_\mathrm{guard}    & = & \{f_\mathtt{check}\} \nonumber \\
Q_\mathrm{func}     & = & \mathbb{R} \nonumber \\
q_{_0\mathrm{func}} & = & 0 \nonumber
%f_\mathtt{copyStore}    & : &  \nonumber
\end{eqnarray}
\end{example}
  
% The actions $f_\mathrm{action} \in F_\mathrm{action}$ of the actor functionality map action dependant number $N$ of input values $(v_1,v_2,\ldots,v_N) = \mathbf{v} \in V^N$ and the current functionality state $q_\mathrm{current} \in Q_\mathrm{func}$ to an action dependant number $M$ of output values $(w_1,w_2,\ldots,w_M) = \mathbf{w} \in V^M$ and the next functionality state $q_\mathrm{next} \in Q_\mathrm{func}$, i.e.,  $f_\mathrm{action}: V^N \times Q_\mathrm{func} \to V^M \times Q_\mathrm{func}$.

The actions $f_\mathrm{action} \in F_\mathrm{action}$ of the actor functionality map sequences of token values $\mathbf{v}_{i_1},\mathbf{v}_{i_2},\ldots,\mathbf{v}_{i_{|a.I|}} \in V^*$ at the actor input ports $a.I$ into sequences of token values $\mathbf{v}_{o_1},\mathbf{v}_{o_2},\ldots,\mathbf{v}_{o_{|a.O|}} \in V^*$ at the actor output ports $a.O$, thereby potentially also modifying the functionality state:

\begin{equation}
f_\mathrm{action} : V^{N_{i_1}} \times V^{N_{i_2}} \ldots \times V^{N_{i_{|a.I|}}} \times Q_\mathrm{func} \to V^{M_{o_1}} \times V^{M_{o_2}} \ldots \times V^{M_{o_{|a.O|}}} \times Q_\mathrm{func}  \nonumber
\end{equation}

\noindent
In the above equation, $N_i \in \mathbb{N}_{0}$ denotes the number of tokens that are consumed from the current token sequence $\mathbf{v}_{i}$ at the $i$th actor input port by the firing FSM after the action $f_\mathrm{action}$ has finished.
Similarly, $M_o \in \mathbb{N}_{0}$ denotes the number of tokens designated for the $o$th actor output port produced by the firing FSM after the action $f_\mathrm{action}$ has computed the associated values for these tokens.
Note that in the most general case of an actor, the number of token values read as well as 
the number of token values computed by an action may be dependent also on the 
state of the actor. The same holds, of course also for the values computed by the 
action. Hence, $N_i$ and $M_o$ may be also state-dependent in the most 
general case. We assume for now that $N_i$ and $M_o$ denote statically computable
fixed upper bounds on the length of sequences of tokens the values of which
are used/computed by an action. In general, 
one must be very careful, however, about treating actions and guards 
as functions in the pure mathematical sense.
Finally, please note also that actions and guards are not responsible 
for determining how many 
tokens will be consumed and how many tokens will be produced each time an actor 
processes tokens. This concern is separated from the computation of token values 
and ruled uniquely by the firing finite state machine that will be described next. 
Before describing the notion of the firing state machine, we will introduce 
the difference between actions and guards.

% The guards $f_\mathrm{guard} \in F_\mathrm{guard}$ of the actor functionality map a guard dependant number $N$ of input values $(v_1,v_2,\ldots,v_N) = \mathbf{v} \in V^N$ and the current functionality state $q_{i} \in Q_\mathrm{func}$ to a boolean value, i.e.,  $f_\mathrm{guard}: V^N \times Q_\mathrm{func} \to \{\mathrm{true},\mathrm{false}\}$.

A guard $f_\mathrm{guard} \in F_\mathrm{guard}$ of the actor functionality maps sequences of token values $\mathbf{v}_{i_1},\mathbf{v}_{i_2},\ldots,\mathbf{v}_{i_{|a.I|}} \in V^*$ at the  actor input ports $a.I$ and the functionality state to a boolean value:

\begin{equation}
f_\mathrm{guard} : V^{N_{i_1}} \times V^{N_{i_2}} \ldots \times V^{N_{i_{|a.I|}}} \times Q_\mathrm{func} \to \{\mathrm{false}, \mathrm{true} \} \nonumber
\end{equation}

\noindent
In the above equation, $N_i \in \mathbb{N}_{0}$ denotes the number of tokens on the input port $i$ needed for computing the boolean guard decision. Note that similar to 
actions, the sequence lengths $N_i$ may also be dependent on the current functionality state of the actor in the most general case and must hence be considered to be upper bounds in the 
above equation.

In summary, there are, however, two fundamental differences of actions and guards:
(i) A guard function just returns a boolean value instead of computing values of tokens 
for output ports, and (ii), a guard must be side-effect free in the sense that it must 
not be able to change the functionality state. In our implementation, we 
guarantee this second property by requiring that guards need to be declared as 
\emph{const member functions}.


The input values for the actor functionality are provided by the firing FSM which retrieves input values from the tokens in the FIFO channels connected to the actor input ports.
Output values from actions $f_\mathrm{action}$ are used by the firing FSM to generate tokens for the FIFO channels connected to the actor output ports.




\subsection{Actor communication behavior}\label{sec:firing-fsm}

The consumption and production of tokens is locally triggered by transitions 
of an explicit \emph{firing FSM} required in each actor.
The purpose and advantage of this clear separation of that part 
that does computation on token values (in 
actions and guards) from the control of the behavior of an actor in particular 
to our \SysteMoC{} approach and inspired by the following advantages: 
\begin{itemize}
\item {\em recognizability}: recognize important data-flow models of computation such 
as SDF, and CSDF just from the complexity of the firing FSM.
\item {\em analyzability}: As a consequence of being able to detect important 
well-known models of computation within \SysteMoC{} actors and actor network 
graphs, many important and well-known analysis algorithms such as 
boundedness of memory, liveness and periodicity properties may be applied
immediately.
\item {\em optimizability}: As an immediate consequence, buffer minimization 
and scheduling algorithms may be applied on individual or subgraphs of actors.
\item {\em simulatability}: Finally, even most complex actor networks may be 
handled for which no formal analysis techniques are known by simply simulating the 
network of actors. As \SysteMoC{} is built on top of SystemC, an event-driven 
simulation of the exact timing and concurrency among actors is immediately possible.
\item {\em refinement}: We expect to show another important 
feature of \SysteMoC{} in the future, namely a transformative refinement of actor code:
We intend to apply important refinement transformations towards a final 
target implementation by providing transformations on the specification, 
and finally, also automatic platform-based automatic code synthesis is envisioned.
This will be, however, a topic of future work. 
\end{itemize} 

The notion of firing FSM is similar to the concepts introduced in SPI~\cite{ZERTT99a} and an extension of the \emph{finite state machines} in FunState~\cite{STZETG00} by allowing requirements for a minimum of space available in output channels before a transition can be taken.
The states of the firing FSM are called \emph{firing states}, directed edges between these firing states are called \emph{firing transitions} or \emph{transitions} for short.
Each transition is annotated with an \emph{activation pattern}, a boolean expression which decides if the transition can be taken, and an \emph{action} from the \emph{actor functionality} which is executed if the transition is taken.
The activation patterns are partitioned into:
 (i)   Predicates on the number of available tokens on the input ports called \emph{input patterns}, e.g., $i_1(1)$ denotes a predicate that tests the availability of at least one token at the actor input port $i_1$,
 (ii)  predicates on the number of free places on the output ports called \emph{output patterns}, e.g., $o_1(1)$ checks if at least one free place is available at the output port $o_1$, and
 (iii) more general predicates called \emph{functionality conditions} depending on the \emph{functionality state} or the token values on the input ports.
% An \emph{activation pattern} may consist of an \emph{input pattern} and an \emph{output pattern}. Input (output) patterns are responsible for checking conditions on the actor input (output) ports, respectively.
More formally, we derive the following two definitions:

\begin{definition}[Firing FSM]\label{def:firing-fsm}
  The \emph{firing FSM} of an actor $a \in A$ is a tuple $a.\mathcal{R} =$ $(T,$ $Q_\mathrm{firing},$ $q_{_0\mathrm{firing}})$ containing
  a finite set of \emph{firing transitions} $T$, % \subseteq Q_\mathrm{firing} \times \mathcal{K} \times A.\mathcal{F}.F_\mathrm{action} \times Q_\mathrm{firing}$,
  a finite set of \emph{firing states} $Q_\mathrm{firing}$ and
  an \emph{initial firing state} $q_{_0\mathrm{firing}} \in Q_\mathrm{firing}$.
\end{definition}

\begin{definition}[Transition]\label{def:firing-transition}
  A \emph{firing transition} is a tuple $t = (q_\mathrm{firing}, k, f_\mathrm{action}, q'_\mathrm{firing})$  $\in T$ containing
  the current firing state $q_\mathrm{firing} \in Q_\mathrm{firing}$,
  an \emph{activation pattern} $k$,
  the associated \emph{action} $f_\mathrm{action} \in a.\mathcal{F}$,
  and the next firing state $q'_\mathrm{firing} \in Q_\mathrm{firing}$.
  The activation pattern $k$ is a boolean function which decides if 
  transition $t$ can be taken $(\mathrm{true})$ or not $(\mathrm{false})$.
  %$k(\mathbf{v}, q_\mathrm{func}) = \mathrm{true}$, or
  %can not be taken $k(\mathbf{v}, q_\mathrm{func}) = \mathrm{false}$.
% or more input values are still neccessary to decide $k(\mathbf{v}, q_\mathrm{func}) = \bot$.
% Where $k$ is a function from
% the \emph{input alphabet} $\chi = (V^{**})^{|A.I|} \times \mathbb{Z}^{|A.O|}$ and the \emph{functionality state}
% $A.\mathcal{F}.Q_\mathrm{func}$ to the trinary boolean set $\{\bot, \mathrm{true}, \mathrm{false}\}$, i.e.,
% $k: \chi \times A.\mathcal{F}.Q_\mathrm{func} \to \{\mathrm{true}, \mathrm{false}\}$.
\end{definition}

\begin{figure}[t]
\centering
\scalebox{1}[1]{\input{firing-rules-sqrloop-fig.tex}}
%\includegraphics[width = 5in]{firing-rules-sqrloop}
\caption{\label{fig:firing-rules-sqrloop}%
Visual representation of the \emph{firing FSM} of the \code{SqrLoop} actor $a_2$ shown in Figure~\ref{fig:ng-sqrroot}.
The \code{SqrLoop} actor controls the number of iterations performed by Newton's square root algorithm.
}
\end{figure}

\begin{example}
In the above figure, the firing FSM of the \code{SqrLoop} is shown.
From the $q_\mathrm{start}$ state only the transition $t_1$ can be taken, which blocks until at least one token is available on input port $i_1$ and one token can be written on output port $o_1$.
The first token at input port $i_1$ represents the input value for the square root algorithm. It is stored and forwarded by action $f_\mathtt{copyStore}$ via port $o_1$ to the approximation loop body $a_3$ - $a_4$ of Newton's algorithm.

From state $q_\mathrm{loop}$, either the transition $t_2$ can be taken if the approximation satisfies the error bound \code{BOUND}, or the transition $t_3$ if another approximation step is necessary.
This termination criteria is determined by the guard $f_\mathtt{check}$. 
% from its actor functionality $a_2.\mathcal{F}$
Furthermore, both transitions $t_2$ and $t_3$ can only be taken if at least one approximation value (token) is available via port $i_2$.
Finally, for transition $t_2$ and $t_3$ to be ready to be taken, at least space to write one token on output port $o_2$ and output port $o_1$ must be available, respectively.
Whereas the transition $t_2$ forwards the square root approximation to the \code{Sink} actor $a_5$ and transition $t_3$ forwards the input value for the square root algorithm again to the approximation loop body to calculate a refined approximation.
\end{example}

As said before, the activation pattern $k$ may consist of patterns specifying the availability of tokens on the input ports and the availability of free space in the output ports of an actor.
In this paper, we will not formally define activation patterns.
Instead, we introduce them throughout our running example.

Note that in case at a certain instant of time, more than one transition should be 
ready to be taken, we assume that one of these transitions is chosen non-deter\-ministi\-cally.

% Der obig definierte Zustandsautomat,
% auch graphisch dargestellt in Abbildung \ref{fig:firing-rules-sqrloop},
% besteht aus einem Zustand \code{start} und zwei Selbstschleifen,
% den Transitionen $\mathbf{t_1}$ und $\mathbf{t_2}$.

In the following Example~\ref{ex:systemoc-sqrloop-fsm-def}, the \SysteMoC{} representation of the firing FSM of the \code{SqrLoop} actor $a_2$, also visually represented in Figure~\ref{fig:firing-rules-sqrloop}, is given.

\begin{example}\label{ex:systemoc-sqrloop-fsm-def}%
Declaration of the firing FSM:
\begin{verbatim}
class SqrLoop: public smoc_actor {
  ...
  // Declaration of states for the firing FSM
  smoc_firing_state start, loop;
public:
  // Constructor responsible for declaring the
  // firing FSM and initializing the actor
  SqrLoop(sc_module_name name)
    : smoc_actor( name, start /* start state of firing FSM */ ) {
    // Declaration of start state consisting
    // of one outgoing transition t1
    start =
      // transition t1
        // with input pattern requiring at least one token
        // in the FIFO connected to input port i1
        i1(1)                               >>
        // with output pattern requiring at least space for one token
        // in the FIFO connected to output port o1
        o1(1)                               >>
        // has action SqrLoop::copyStore and next state loop
        CALL(SqrLoop::copyStore)            >> loop
      ;
    // Declaration of loop state consisting of two transitions t2 and t3
    loop  =
      // transition t2
        // with input pattern requiring at least one token
        // in the FIFO connected to input port i2 and
        // that guard SqrLoop::check be true
        (i2(1) &&  GUARD(SqrLoop::check))   >>
        // with output pattern requiring at least space for one token
        // in the FIFO connected to output port o2
        o2(1)                               >>
        // has action SqrLoop::copyApprox and next state start
        CALL(SqrLoop::copyApprox)           >> start
      // transition t3
        // with input pattern requiring at least one token
        // in the FIFO connected to input port i2 and
        // that guard SqrLoop::check be false
      | (i2(1) && !GUARD(SqrLoop::check))   >>
        // with output pattern requiring at least space for one token
        // in the FIFO connected to output port o1
        o1(1)                               >>
        // has action SqrLoop::copyInput and next state loop
        CALL(SqrLoop::copyInput)            >> loop
      ;
  }
};
\end{verbatim}
\end{example}

% Die Aktivierungsregeln werden als endliche Zustandsautomaten implementiert,
% welche im Konstruktor der Aktorklasse aufgebaut werden.
% Die Aktivierungszustände werden als Instanzen der \code{smoc\_firing\_state} Klasse deklariert,
% z.B. im obigen Quellcode der \code{start}-Aktivierungszustand.
% Von den deklarierten Aktivierungszuständen wird einer als
% Startzustand selektiert, indem er an die Basisklasse \code{smoc\_actor} übergeben wird.
  
In \SysteMoC{} firing states are represented as instances of the class \code{smoc\_fi\-ring\_state} and declared as
member variables of the corresponding actor class.
One firing state is selected as the start state by passing it to the \code{smoc\_actor} base class of the actor class.
The firing FSM is specified in the constructor of the actor class by assigning each firing state its set of outgoing transitions.
The syntax used in the above example to declare the firing FSM is given in the following as extended \emph{Backus-Naur form} (\emph{BNF}):
%Syntax~\ref{syn:systemoc-fsm-bnf}

\begin{syntax}\label{syn:systemoc-fsm-bnf}%
\noindent Extended Backus-Naur form for firing FSM declarations:
\begin{verbatim}
StateDefinition     ::= FiringState '=' OutgoingTransitions ';'

OutgoingTransitions ::= Transition '|' OutgoingTransitions |
                        Transition                         ;

Transition          ::= ActivationPattern '>>' Action '>>' FiringState |
                                               Action '>>' FiringState |
                        ActivationPattern             '>>' FiringState ;

ActivationPattern   ::= InputPattern '&&' FunCond '>>' OutputPattern |
                                          FunCond '>>' OutputPattern |
                        InputPattern              '>>' OutputPattern |
                        InputPattern '&&' FunCond                    |
                                                       OutputPattern |
                                          FunCond                    |
                        InputPattern                                 ;

Action              ::= 'CALL' '(' <actor action> ')' ;

InputPattern        ::= '(' InputPattern  ')'               |
                        InputExpression  '&&' InputPattern  |
                        InputExpression                     ;

OutputPattern       ::= '(' OutputPattern ')'               |
                        OutputExpression '&&' OutputPattern |
                        OutputExpression                    ;

InputExpression     ::= InputPort  '.getAvailableTokens()' '>=' Expr |
                        InputPort  '(' Constant ')'                  ;

OutputExpression    ::= OutputPort '.getAvailableSpace()'  '>=' Expr |
                        OutputPort '(' Constant ')'                  ;

InputPort           ::= <actor input port>

OutputPort          ::= <actor output port>

FunCond             ::= Expr ;
\end{verbatim}
\end{syntax}

\code{FiringStates} are defined by assigning them their set of \code{OutgoingTransitions}.
This transition set is created by combining their member \code{Transitions} via the \code{|}-operator.
The transitions themselves are created by combining an \code{InputPattern}, an \code{OutputPattern}, an \code{Action}, and the next \code{FiringState} via the \code{>>}-operator.
Whereas input pattern, output pattern, and action are optional, but at least one of them must be present.
If an action is used the included \code{<actor action>} is declared in the actor functionality, as defined previously in Subsection~\ref{sec:actor-functionality}.

As can be seen in the Example~\ref{ex:systemoc-sqrloop-fsm-def} input and output patterns are assembled via the \code{\&\&}-operator\footnote{C++ logical AND} from \code{InputExpressions} and \code{OutputExpressions} respectively.
Whereas input expressions check available tokens on input ports, e.g., \code{i1(1)} to check that at least one token is available on port \code{i1}, and output expressions check available space on output ports, e.g., \code{o1(1)} to check that at least one token can be written on port \code{o1}.
The input expression \code{i1(n)} and output expression \code{o1(m)} are used as shortcuts for the longer forms \code{i1.getAvailableTokens() >= n} and \code{o1.getAvailableSpace() >= m} respectively.

As can be seen in the previous syntax definition activation patterns can have additional \emph{functionality conditions} (\code{FunCond}) checking, e.g., token values on input ports or the functionality state of the actor.
A functionality condition is simply an expression \emph{Expr} which is constraint to have a boolean type.
The syntax rules for legal compositions of these expressions is given below.

\begin{syntax}\label{syn:systemoc-fsm-bnf-2}%
\noindent Extended Backus-Naur form of expressions used in activation patterns:
\begin{verbatim}
Expr                ::= Expr '+'  Expr | Expr '-'  Expr |
                        Expr '*'  Expr | Expr '/'  Expr |
                        Expr '==' Expr | Expr '!=' Expr |
                        Expr '<'  Expr | Expr '<=' Expr |
                        Expr '>'  Expr | Expr '>=' Expr |
                        Expr '^'  Expr | Expr '&'  Expr |
                        Expr '|'  Expr | Expr '&&' Expr |
                        Expr '||' Expr | '(' Expr ')'   |
                        '!' Expr       | '~' Expr       |
                        Terminal       ;
                        
Terminal            ::= Constant | Variable | Guard | Token ;

Constant            ::= <C++ integer expression> ;

Variable            ::= 'VAR' '(' <actor member variable> ')' ;

Guard               ::= 'GUARD' '(' <actor guard member function> ')' ;

Token               ::= InputPort '.getValueAt' '(' Constant ')' ;
\end{verbatim}
\end{syntax}

% TypeCheck           ::= 'isType' '<' <Type> '>' '(' Expr ')' ;

The expressions can be combined via C++ operators listed in the preceding syntax definition, e.g., \code{+} for arithmetic addition.
The precedence of these operators is exactly their C++ precedence.
A expression can be combined from the following terminals:
(i)   the \code{Constant}-terminal represents a C++ expression which evaluates at instantiation time of the expression to a C++ integer, e.g., \code{sqr(a+5)}. A later value change of a variable included in this C++ expression, e.g., \code{a}, will not change the value of instantiated \code{<Integer>}-terminals containing this variable.
(ii)  the \code{Variable}-terminal represents a actor member variable. A later value change of this variable will change the value of the \code{<Variable>}-terminal.
(iii) the \code{Guard}-terminal represents an actor guard, as defined previously in Subsection~\ref{sec:actor-functionality}. The value of the \code{Guard}-terminal is returned by its guard function and may depend on token values and the functionality state of the actor.
(iv)  the \code{Token}-terminal, e.g., \code{i.getValueAt(n)}, represents the \code{n}th token on an actor input port \code{i}. Where \code{n} is starting from zero, e.g., \code{i.getValueAt(0)} is the first token in the channel connected to input port \code{i}

\subsection{Actor parameters}\label{sec:constr-params}

As mentioned in Section~\ref{sec:network-graph} actors can be parameterized using constructor parameters, e.g., as seen in Example~\ref{ex:systemoc-networkgraph} where the \code{Src} actor $a_1$, also displayed below, is parameterized \code{src("a1", 50)} to produce ascending values beginning from fifty.

\begin{example}\label{ex:systemoc-src-actor-def}%
Definition of the \code{Src} actor class:
\begin{verbatim}
class Src: public smoc_actor {
public:
  smoc_port_out<double> out;
private:
  int i;
  
  void src() { out[0] = i++; }
  
  smoc_firing_state start;
public:
  Src(sc_module_name name, SMOC_ACTOR_CPARAM(int,from))
    : smoc_actor(name, start), i(from) {
    start =
        (VAR(i) <= 100)           >>
        out(1)                    >>
        CALL(Src::src)            >> start
      ;
  }
};
\end{verbatim}
\end{example}

To enable the \SysteMoC{} synthesis framework to extract the value of these constructor parameters they must be wrapped with the \code{SMOC\_ACTOR\_CPARAM(type, name)} macro.
The extraction of these parameters via code parsing of the executable \SysteMoC{} specification is in general not possible because these parameters may depend on data not included in the \SysteMoC{} code, e.g., they may be derived from a configuration file.
Therefore, it is necessary that these values are extracted at run time after the SystemC elaboration phase has finished.
To facilitate this extraction the constructor parameters are wrapped by the \code{SMOC\_ACTOR\_CPARAM(type, name)} which enables the retention of the values of these parameters, till they can be inserted into an XML representation of the network graph which can be generated after the SystemC elaboration phase has finished.
Note that the macro must not be applied to the \code{sc\_module\_name} parameter.
