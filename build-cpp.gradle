// vim: set syntax=groovy sts=2 ts=8 et:

import de.jfalk.gradle.JFHelperFunctions;

apply plugin: 'de.jfalk.gradle.cpp'
apply plugin: JFHelperFunctions;

//apply plugin: 'cpp' replaced by JFCppPlugin
apply plugin: 'visual-studio'
//apply plugin: 'eclipse'
//apply plugin: 'eclipse-cdt' <= This does not really work at the moment

// Here, ``this'' is the current org.gradle.api.Project
//this.buildDir = 'obj-gradle'

import java.util.regex.Matcher 

class GenerateSysteMoCConfigH extends DefaultTask {
  @InputFile       File templateFile
  @OutputDirectory File headerDir
  @OutputDirectory File sourceDir
  // The associated binary for the generated config header.
  Binary                binary;

  @TaskAction
  void generateSysteMoCConfigH() {
    def m = templateFile.path =~ /[\/\\]headers[\/\\](.*)\.in$/
    assert m instanceof Matcher
    assert m
    File output = new File(headerDir, m.group(1))
    output.parentFile.mkdirs()
    output.text = '';
//  println binary.flavor
    templateFile.eachLine { line ->
      def mline = line =~ /#undef ([^ ]*)/;
//    String quotedLine = line.replaceAll(/["\\]/) { c -> '\\'+c }
      if (mline) {
        if (mline.group(1) == 'SYSTEMOC_VERSION') {
          output.append("#define "+mline.group(1)+" \"1.0\"\n")
        } else if (mline.group(1) == 'SYSTEMOC_MAJOR_VERSION') {
          output.append("#define "+mline.group(1)+" \"1\"\n")
        } else if (mline.group(1) == 'SYSTEMOC_MINOR_VERSION') {
          output.append("#define "+mline.group(1)+" \"0\"\n")
        } else if (mline.group(1) == 'SYSTEMOC_MICRO_VERSION') {
          output.append("#define "+mline.group(1)+" \"0\"\n")
        } else if (mline.group(1) == 'SYSTEMOC_ENABLE_DEBUG') {
          if (binary.buildType.name == 'debug') {
            output.append("#define "+mline.group(1)+" yes\n")
          } else {
            output.append("/* #undef "+mline.group(1)+" */\n")
          }
        } else if (mline.group(1) == 'SYSTEMOC_ENABLE_SGX') {
          if (binary.flavor.name.matches('(?i).*sgx.*')) {
            output.append("#define "+mline.group(1)+" yes\n")
          } else {
            output.append("/* #undef "+mline.group(1)+" */\n")
          }
        } else if (mline.group(1) == 'SYSTEMOC_ENABLE_VPC') {
          if (binary.flavor.name.matches('(?i).*vpc.*')) {
            output.append("#define "+mline.group(1)+" yes\n")
          } else {
            output.append("/* #undef "+mline.group(1)+" */\n")
          }
        } else {
          output.append("/* unknown definition "+line+" */\n")
        }
      } else {
        output.append(line+"\n")
      }
    }
  }
}

model {
  buildTypes {
    debug
    release
  }
  flavors {
    create('default')
    create('Sgx')
//  create('Vpc')
//  create('Maestro')
//  create('SgxVpc')
//  create('SgxMaestro')
//  create('SgxMaestroCrescendo')
  }
  components {
    "systemoc"(JFNativeLibrarySpec) {
      sources {
        cpp {
          source {
            exclude "**/*"
          }
//        exportedHeaders {
//          srcDirs "src/systemoc/headers"
//        }
        }
      }
      binaries.all {
        def binary          = it
        def configHeaderDir = new File(namingScheme.getOutputDirectory(new File(buildDir, "src")), "headers")
        sources {
          cpp(JFCppSourceSet) {
            source {
              srcDirs "src/systemoc/cpp"
//            srcDirs "src/systemoc/headers-connfig"
              include "**/*.cpp"
            }
            exportedHeaders {
              srcDirs "src/systemoc/headers"
              srcDirs configHeaderDir
            }
//          if (binary.flavor == flavors.vpc) {
//            println "flavors.vpc"
//          } else if (binary.flavor == flavors.maestro) {
//            println "flavors.maestro"
//          }
            lib project: ':PrebuiltLibraries', library: "boost_headers", flavor: "default", exportHeaders: true
            lib project: ':PrebuiltLibraries', library: "boost_program_options", flavor: "default"
            lib project: ':Support', library: "cosupport-base", flavor: "default", exportHeaders: true
            lib project: ':Support', library: "cosupport-systemc", flavor: "default", exportHeaders: true
            lib project: ':Support', library: "cosupport-tracing", flavor: "default"
            lib project: ':Support', library: "cosupport-streams", flavor: "default", exportHeaders: true
            lib project: ':Support', library: "cosupport-smartptr", flavor: "default"
            lib project: ':Support', library: "cosupport-allocators", flavor: "default"
            lib project: ':Support', library: "cosupport-math", flavor: "default"
            lib project: ':Support', library: "cosupport-string", flavor: "default", exportHeaders: true
            if (binary.flavor.name.matches('(?i).*Sgx.*')) {
              lib project: ':LibSGX',      library: "libsgx",      flavor: "default", exportHeaders: false
              lib project: ':LibSGXUtils', library: "libsgxutils", flavor: "default", exportHeaders: false
            }
//          if (binary.flavor.name.matches('(?i).*MaestroCrescendo.*')) {
//            lib project: ':Maestro:MetaMap', library: "libmaestro-metamap", flavor: "bruckner", exportHeaders: true
//          } else if (binary.flavor.name.matches('(?i).*Maestro.*')) {
//            lib project: ':Maestro:MetaMap', library: "libmaestro-metamap", flavor: "default", exportHeaders: true
//          } else if (binary.flavor.name.matches('(?i).*Vpc.*')) {
//            lib project: ':SystemC-VPC', library: "systemcvpc", flavor: "default", exportHeaders: true
//          }
            exportedCompilerArgs.define "FLIMMY_DEFINE=4711"
          }
        }
        tasks.create(tasks.taskName('configHeaderGeneration'), GenerateSysteMoCConfigH.class) { task ->
          sources.cpp.generatedBy task
          task.description  = "Generate smoc_config.h for the selected configuration of the libsystemoc binary."
          task.templateFile = project.file("src/systemoc/headers/systemoc/smoc_config.h.in")
          task.headerDir    = configHeaderDir
          task.sourceDir    = configHeaderDir
          task.binary       = binary
        }
//      tasks.withType(CppCompile) {
//        includes "src/systemoc/headers-connfig"
//      }
//      if (flavor == flavors.Vpc) {
//        cppCompiler.define "FLOMMY_DEFINE=\"vpc\""
//      } else if (flavor == flavors.Maestro) {
//        cppCompiler.define "FLOMMY_DEFINE=\"maestro\""
//      } else if (flavor == flavors.'SgxVpc') {
//        cppCompiler.define "FLOMMY_DEFINE=\"sgx-vpc\""
//      } else if (flavor == flavors.'SgxMaestro') {
//        cppCompiler.define "FLOMMY_DEFINE=\"sgx-maestro\""
//      }
      }
    }
  }
  binaries {
    all {
//    println "YYYY: class: " + it.class + ", name: " + it.name
//    for (NativeDependencySet lib : it.getBackingNode().getPrivateData().libs) {
//      println "YYYY:    lib.class: " + lib.getClass();
//    }
//    for (LanguageSourceSet foo : it.getInputs()) {
//      println "YYYY:  foo.class: " + foo.getClass();
//    }
//    for (LanguageSourceSet foo : it.getInputs()) {
//      println "YYYY:  foo.class: " + foo.getClass();
//    }

//    analysis("binary", it)
//    println "TOOLCHAIN: " + toolChain
      // Specify toolchain-agnostic stuff
      if (buildType.name == 'release') {
        cppCompiler.define "NDEBUG"
      }
//    cppCompiler.define "COSUPPORT_DLL_IMPORT"
      // Define toolchain-specific compiler and linker options
      if (toolChain in VisualCpp) {
        // Enable standard C++ exception for visual studio
        cppCompiler.args "/EHsc" //, '/I"C:/Program Files (x86)/Windows Kits/10/Include/10.0.10586.0/ucrt/"'
        linker.args "/LIBPATH:" + rootProject.childProjects.get('PrebuiltLibraries').projectDir + "\\i686-msvc120-win\\libboost-1_55\\lib"
        if (buildType.name == 'debug') {
          cppCompiler.args "/Z7", "/MDd"
          linker.args "/DEBUG"
        } else {
          cppCompiler.args "/MD"
        }
      } else if (toolChain in Gcc) {
        cppCompiler.args "-Wall", "-std=gnu++11"
        cCompiler.args "-Wall", "-std=gnu99"
        linker.args "-Xlinker", "-S"
        if (buildType.name == 'debug') {
          cppCompiler.args "-ggdb"
          cCompiler.args "-ggdb"
        } else {
          cppCompiler.args "-O2"
          cCompiler.args "-O2"
        }
      }
    }
    // For any shared library binaries built with Visual C++, define the DLL_EXPORT macro
    withType(SharedLibraryBinarySpec) {
      if (toolChain in VisualCpp) {
        def dllExportDefine = it.component.name.toUpperCase().inject("") {
            result, c -> c >= 'A' && c <= 'Z' ? result + c : result + '_'
          } + "_DLL_EXPORT"
//      println "FLUMMY: " + dllExportDefine
        cppCompiler.define dllExportDefine
      }
    }
    withType(SharedLibraryBinarySpec) {
      cppCompiler.define "COSUPPORT_DLL_IMPORT"
      cppCompiler.define "SYSTEMC_DLL_IMPORT"
      cppCompiler.define "BOOST_ALL_DYN_LINK"
    }
    withType(NativeExecutableBinarySpec) {
      cppCompiler.define "COSUPPORT_DLL_IMPORT"
      cppCompiler.define "SYSTEMC_DLL_IMPORT"
      cppCompiler.define "BOOST_ALL_DYN_LINK"
    }
  }
}
