actor reconstruct ( int DCVAL, int LBSIZE )
  List(type:int, size=64) DATA, int FLAGS, int PARAM, int A, int B, int C, int DC ==> List(type:int, size=64) OUT, int OFLAGS :

// Die ersten 64 Werte stellen dar, wie die Originalscanfolge (Zeile für Zeile) be JPEG 
// wieder aus den Zigzac-gescannten Werten regeneriert werden kann. Bsp.: die 5 sagt, dass
// das Bildelement (0. Zeile, 2. Spalte) als 6. Element gescannt wurde (beginnt bei 0)
// Die zweiten und dritten 64 Werte werden gebraucht bei Intra-Frame-Codierung
  List[ List [ int ] ] zigzag = 
  [ [  0,  1,  5,  6, 14, 15, 27, 28,  2,  4,  7, 13, 16, 26, 29, 42,
       3,  8, 12, 17, 25, 30, 41, 43,  9, 11, 18, 24, 31, 40, 44, 53,
      10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60,
      21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63 ],
    [  0,  4,  6, 20, 22, 36, 38, 52,  1,  5,  7, 21, 23, 37, 39, 53,
       2,  8, 19, 24, 34, 40, 50, 54,  3,  9, 18, 25, 35, 41, 51, 55,
      10, 17, 26, 30, 42, 46, 56, 60, 11, 16, 27, 31, 43, 47, 57, 61,
      12, 15, 28, 32, 44, 48, 58, 62, 13, 14, 29, 33, 45, 49, 59, 63 ],
    [  0,  1,  2,  3, 10, 11, 12, 13,  4,  5,  8,  9, 17, 16, 15, 14,
       6,  7, 19, 18, 26, 27, 28, 29, 20, 21, 24, 25, 30, 31, 32, 33,
      22, 23, 34, 35, 42, 43, 44, 45, 36, 37, 40, 41, 46, 47, 48, 49,
      38, 39, 50, 51, 56, 57, 58, 59, 52, 53, 54, 55, 60, 61, 62, 63 ]
  ];

// initList generiert eine Liste mit size Elementen und initialisiert alle Werte mit dem Wert v
  function initList( v, size ) :
    [ v : for i in Integers( 1, size ) ]
  end

// Note: LBSIZE should be 6 * (max_line_width_in_mb + 2 )
// FIXME: lb should be mutable, not assignable.

// lb steht für einen lokalen Puffer, der pro Block 15 Werte speichert, die bei Intra-Frame gebraucht werden.
// lb_in stellt den aktuell zu bearbeitenden Block dar.
// block_count auch; Unterschied: block_count wird bei intra-Frame immer, lb_in modulo LBSIZE erhöht.
  List[ List [ int ] ] lb   := initList( initList( 0, 15 ), LBSIZE  );
  int lb_in       := 0;
  int block_count := 0;

// scan liefert die Liste von 64 Elementen eines Blocks zurück mit der Reihenfolge, die durch 
// die Zigzag-Scan-Ordnung pat gegeben ist
  function scan( d, pat ) :
    [ d [ pat [i] ] : for i in Integers( 0, 63 ) ]
  end

// 1. Aktion: Ist der Guard type<0, dann wird eof ("end of frame") ausgeführt.
// Dabei wird lediglich die Variable block_count wieder of 0 gesetzt.
  eof: action PARAM:[ type, x, y, n ] ==>
  guard
   type < 0
  do
    block_count := 0;
  end

// 2. Aktion: Ist der Guard type=1, dann wird als Ausgangsfolge ein Block erzeugt
// mit der durch zigzag[0] bestimmten Reihenfolge (vgl. JPEG)
// Als Ausgangsflags wird type=1 weitergegeben sowie die Werte q und scaler durchgereicht.
  inter: action PARAM:[ type, x, y, n ], FLAGS:[ac, q, scaler], DATA:[d] ==>
         OUT:[ scan( d, zigzag [0] ) ], OFLAGS:[ 1, q, scaler ]
  guard
   type = 1
  end

// 3. Aktion: getdc setzt den Wert im local buffer des aktuellen Blocks lb_in auf den Wert dc.
  getdc: action DC:[dc] ==>
  do
    lb [ lb_in, 0 ] :=  dc ;
  end

// lb_get_val holt aus dem Puffer buf einen Wert zurück. Dabei bestimmen
// pos: lb_in;
// size: Gesamtgröße von buf;
// seq: sequencer
// head: block_count
// index: Offset
  function lb_get_val( buf, pos, size, seq, head, index ) :
    if seq = 0 then
      DCVAL
    else
      if (pos + ( seq - head )) < 0 then
        buf [pos + ( seq - head ) + size, index ]
      else
        buf [pos + ( seq - head ), index ]
      end
    end
  end

// abs berechnet den Betrag einer Zahl
  function abs( x ) :
    if x < 0 then (-x) else x end
  end

// 4. Aktion: Sehr ähnlich wie Aktion inter, außer dass hier noch die drei Werte 
// A, B, und C verarbeitet werden. Diese bestimmen, ob die Zigzag-Tabelle 1 oder 2 
// verwendet wird. Die Aktion wird ausgeführt, wenn der Guard type=0 ist.
  intra: action PARAM:[ type, x, y, n ], FLAGS:[ ac, q, scaler], DATA:[dd], A:[a], B:[b], C:[c] ==>
         OUT:[ scan( d, zigzag [zsel] ) ], OFLAGS:[ 0, q, scaler ]
  guard
   type = 0
  var
    int dca = lb_get_val( lb, lb_in, LBSIZE, a, block_count, 0 ),
    int dcb = lb_get_val( lb, lb_in, LBSIZE, b, block_count, 0 ),
    int dcc = lb_get_val( lb, lb_in, LBSIZE, c, block_count, 0 ),
    int horiz = abs( dcb - dcc ),
    int vert  = abs( dca - dcb ),
    int zsel = 0,
    int pred,
    int t,
    // lokale Kopie der Eingabedaten (1 Block) erzeugen, da diese hier verändert werden
    // bevor die Ausgabe erfolgt.
    List[int] d = [ dd [i] : for i in Integers(0,63) ]
  do
    if vert < horiz then
      pred := dcc;
      if ac != 0 then
        zsel := 2;
        if c > 0 then
	t := zigzag [2, 1]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 1 ); 
	t := zigzag [2, 2]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 2 ); 
	t := zigzag [2, 3]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 3 ); 
	t := zigzag [2, 4]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 4 ); 
	t := zigzag [2, 5]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 5 ); 
	t := zigzag [2, 6]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 6 ); 
	t := zigzag [2, 7]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, c, block_count, 7 ); 
        end
      end
    else
      pred := dca;
      if ac != 0 then
        zsel := 1;
        if a > 0 then
	t := zigzag [1, 8]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 8 ); 
	t := zigzag [1, 16]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 9 ); 
	t := zigzag [1, 24]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 10 ); 
	t := zigzag [1, 32]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 11 ); 
	t := zigzag [1, 40]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 12 ); 
	t := zigzag [1, 48]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 13 ); 
	t := zigzag [1, 56]; d [t] := d [t] + lb_get_val( lb, lb_in, LBSIZE, a, block_count, 14 ); 
        end
      end
    end
    d[0] := (d[0]  * scaler ) + ( ( pred + rshift(scaler,2) ) / scaler ) * scaler ;

    // Hier werden block_count erhöht und lb_in modulo LBSIZE; 
    block_count := block_count + 1;
    lb_in := lb_in + 1;
    if lb_in >= LBSIZE then
      lb_in := 0;
    end
    // Zuletzt werden die erste Zeile und erste Spalte des nächsten lokalen Puffers auf die Werte 
    // des letzten Blocks gesetzt.
    lb [lb_in] := [ d [zigzag [zsel, i]] : for i in [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 24, 32, 40, 48, 56 ] ] ;
  end

// Anfangszustand: read. Von hier aus geht es nach read über die 1. Aktion eof (falls guard type<0),
// bzw. ebenfalls nach read über Aktion 2, (falls guard type=1) bzw. nach Zustand wait (Aktion3)
// (falls guard type=0).
// Von Zustand wait geht es immer wieder zurück in den Zustand read, sobald die 3. Aktion
// (getdc) ausgeführt wurde.
  schedule fsm read :
    read( eof   ) --> read;
    read( inter ) --> read;
    read( intra ) --> wait;
    wait( getdc ) --> read;
  end
end


